(()=>{var k=(P,e,t)=>Math.max(P,Math.min(t,e)),M=(P,e)=>(P%e+e)%e,C=()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,P=>{let e=Math.floor(Math.random()*16);return(P=="x"?e:e&3|8).toString(16)});var b=class{id;start;lastDraw;paused;pauseTimestamp;pauseDuration;currColour;backgroundColour;currProgress;lastProgress;lastMutationTimestamp;canvas;context;origin;mutationInterval;cycleDuration_ms;rest;fps;currIteration;nIterations;colours;opacity;opacityDelta;timingFunction;customTimingFunction;drawStyle;constructor(e,t){if(window.isSecureContext?this.id=crypto.randomUUID():this.id=C(),this.start=performance.now(),this.lastDraw=this.start,this.lastMutationTimestamp=this.start,this.pauseTimestamp=0,this.pauseDuration=0,this.canvas=document.getElementById(e),this.canvas===null)throw new Error("Canvas element not found with id: "+e);this.origin={x:Math.floor(this.canvas.width/2),y:Math.floor(this.canvas.height/2)},this.backgroundColour=t?.backgroundColour??null,this.context=this.canvas.getContext("2d"),this.currProgress=t?.currProgress??0,this.lastProgress=t?.lastProgress??0,this.rest=t?.rest??0,this.fps=t?.fps??60,this.cycleDuration_ms=t?.cycleDuration_ms??1e3,this.currIteration=t?.currIteration??0,this.nIterations=t?.nIterations??1/0,this.paused=t?.paused??!1,this.colours=t?.colours??[],this.opacity=t?.opacity??1,this.opacityDelta=t?.opacityDelta??0,this.timingFunction=t?.timingFunction??"sinusoidal",this.customTimingFunction=t?.customTimingFunction??null,this.drawStyle=t?.drawStyle??"fill",this.mutationInterval=t?.mutationInterval??1/0,this.currColour=""}draw=()=>{this.context.clearRect(0,0,this.canvas.width,this.canvas.height),this.backgroundColour!=null&&(this.context.fillStyle=this.backgroundColour,this.context.fillRect(0,0,this.canvas.width,this.canvas.height))};step=()=>{this.seek(1)};seek=e=>{let i=1e3/this.fps/this.cycleDuration_ms;this.lastProgress=this.currProgress,this.currProgress=k(0,this.currProgress+e*i,1),this.lastProgress===1&&(this.currProgress=0),this.draw()};animate=()=>{if(this.paused)return;requestAnimationFrame(this.animate);let e=performance.now(),t=e-this.lastDraw,i=1e3/this.fps;if(t<i)return;e-this.lastMutationTimestamp>=this.mutationInterval&&(this.mutate(),this.lastMutationTimestamp=e),this.lastProgress=this.currProgress,this.currProgress=M(e-this.pauseDuration-this.start,this.cycleDuration_ms)/this.cycleDuration_ms,this.lastProgress>this.currProgress&&(this.currIteration++,this.currIteration>=this.nIterations&&this.pause()),this.draw(),this.lastDraw=e};mutate=()=>{};getProgress=e=>{switch(this.timingFunction){case"sinusoidal":return this.getProgressSinusoidal(e);case"quadratic":return this.getProgressExponential(2,e);case"cubic":return this.getProgressExponential(3,e);case"custom":if(this.customTimingFunction==null)throw new Error("Custom timing function does not exist.");return this.customTimingFunction(e);default:return this.getProgressLinear(e)}};getProgressLinear=e=>{let t=e?(this.currProgress+1+e)%1:this.currProgress;return Math.min(1,t/(1-this.rest))};getProgressExponential=(e,t)=>{let i=t?(this.currProgress+1+t)%1:this.currProgress,r=Math.min(1,i/(1-this.rest));return Math.pow(r,e)};getProgressSinusoidal=e=>{let t=e?(this.currProgress+1+e)%1:this.currProgress,i=Math.min(1,t/(1-this.rest));return .5+Math.sin((i-.5)*Math.PI)/2};play=()=>{this.paused=!1;let e=performance.now();this.lastDraw=e,this.pauseDuration+=e-this.pauseTimestamp,requestAnimationFrame(this.animate)};pause=()=>{this.paused=!0,this.pauseTimestamp=performance.now()};ctxDraw=()=>{this.drawStyle=="fill"?this.context.fill():this.context.stroke()};ctxMoveToVector=e=>{this.context.moveTo(e.x,e.y)};ctxLineToVector=e=>{this.context.lineTo(e.x,e.y)};ctxCircToVector=(e,t,i)=>{let r=this.circularBezierControlPoints(e,t,i);this.context.bezierCurveTo(r.cp1.x,r.cp1.y,r.cp2.x,r.cp2.y,t.x,t.y)};ctxSetColour=e=>{let t=M(e,this.colours.length),r=Math.floor(Math.max(0,this.opacity-(this.colours.length-1-t)*this.opacityDelta)*255).toString(16).padStart(2,"0"),o=`${this.colours[t]}${r}`;this.context.strokeStyle=o,this.context.fillStyle=o,this.currColour=o};ctxModifyOpacity=e=>{let t=this.currColour,i=t.slice(0,7),r=t.slice(7,9),o=parseInt(r,16),a=Math.floor(o+o*e).toString(16).padStart(2,"0"),c=`${i}${a}`;this.context.strokeStyle=c,this.context.fillStyle=c,this.currColour=c};drawDot=e=>{this.context.beginPath(),this.context.arc(this.origin.x+e.x,this.origin.y+e.y,2,0,2*Math.PI),this.context.fill()};circularBezierControlPoints=(e,t,i)=>{let r=i??{x:0,y:0},o=e.x-r.x,s=e.y-r.y,a=t.x-r.x,c=t.y-r.y,n=o*o+s*s,h=n+o*a+s*c,u=4/3*(Math.sqrt(2*n*h)-h)/(o*c-s*a),l=r.x+o-u*s,x=r.y+s+u*o,g=r.x+a+u*c,p=r.y+c-u*a;return{cp1:{x:l,y:x},cp2:{x:g,y:p}}}};var f=class extends b{arcs;arcWidth;arcWidthDelta;arcAnchor;tailDelay;arcDelay;radius;radiusDelta;rotations;mutator;innerBorder;outerBorder;trackColour;lineCap;leadCap;tailCap;constructor(e,t){super(e,t);let i=Math.min(this.canvas.width,this.canvas.height);this.arcs=t?.arcs??1,this.arcWidth=t?.arcWidth??10,this.arcWidthDelta=t?.arcWidthDelta??.02,this.arcAnchor=t?.arcAnchor??"centre",this.tailDelay=t?.tailDelay??.1,this.arcDelay=t?.arcDelay??.1,this.radius=t?.radius??Math.floor(i*.75),this.radiusDelta=t?.radiusDelta??0,this.rotations=t?.rotations??1,this.mutator=t?.mutator??(()=>{}),this.innerBorder=t?.innerBorder??null,this.outerBorder=t?.outerBorder??null,this.trackColour=t?.trackColour??"",this.lineCap=t?.lineCap??"rounded",this.leadCap=t?.leadCap??null,this.tailCap=t?.tailCap??null}parentDraw=this.draw;mutate=()=>{this.mutator(this)};getAccumulatedRotation=()=>(this.currIteration+this.currProgress)*this.rotations*Math.PI*2;draw=()=>{this.parentDraw();let e=this.getAccumulatedRotation();this.drawTrack();for(let t=0;t<this.arcs;t++){let i=M(this.getProgress(this.arcDelay*t)*Math.PI*2+e,Math.PI*2),r=M(this.getProgress(this.arcDelay*t-this.tailDelay)*Math.PI*2+e,Math.PI*2),o=(this.arcs-(t+1))*this.arcWidthDelta*this.arcWidth,s=this.calculateOffsets(t,o),{lead:a,tail:c,leadSection:n,tailSection:h,leadGuide:u,tailGuide:l,sectionBounds:x}=this.calculatePositions(i,r,s,o);this.ctxSetColour(this.arcs-t-1),this.context.beginPath();let g=h,p=!1,T=!1;for(let w=0;w<6;w++){if(h==g&&n==g&&i>r){this.drawContainedArc(c,a,u,l);break}else{if(h==g&&p)break;if(h==g&&!T){T=!0;let m=x[(g+1)%3];this.drawTailArcSection(c,m,l)}else if(n==g){p=!0;let m=x[g];this.drawLeadArcSection(a,m,u)}else{let m=x[g],y=x[(g+1)%3];this.drawMiddleArcSection(m,y,p)}}g=p?(g+2)%3:(g+1)%3}this.ctxDraw()}this.drawBorders()};drawContainedArc=(e,t,i,r)=>{let o=this.circularBezierControlPoints(e.outer,t.outer,this.origin),s=this.circularBezierControlPoints(t.inner,e.inner,this.origin);this.context.moveTo(t.inner.x,t.inner.y),this.context.bezierCurveTo(s.cp1.x,s.cp1.y,s.cp2.x,s.cp2.y,e.inner.x,e.inner.y),this.lineCap=="rounded"||this.tailCap=="rounded"?(this.ctxCircToVector(e.inner,r,e.mid),this.ctxCircToVector(r,e.outer,e.mid)):this.context.lineTo(e.outer.x,e.outer.y),this.context.bezierCurveTo(o.cp1.x,o.cp1.y,o.cp2.x,o.cp2.y,t.outer.x,t.outer.y),this.lineCap=="rounded"||this.leadCap=="rounded"?(this.ctxCircToVector(t.outer,i,t.mid),this.ctxCircToVector(i,t.inner,t.mid)):this.context.lineTo(t.inner.x,t.inner.y)};drawLeadArcSection=(e,t,i)=>{let r=this.circularBezierControlPoints(t.outer,e.outer,this.origin),o=this.circularBezierControlPoints(e.inner,t.inner,this.origin);this.context.bezierCurveTo(r.cp1.x,r.cp1.y,r.cp2.x,r.cp2.y,e.outer.x,e.outer.y),this.lineCap=="rounded"||this.leadCap=="rounded"?(this.ctxCircToVector(e.outer,i,e.mid),this.ctxCircToVector(i,e.inner,e.mid)):this.context.lineTo(e.inner.x,e.inner.y),this.context.bezierCurveTo(o.cp1.x,o.cp1.y,o.cp2.x,o.cp2.y,t.inner.x,t.inner.y)};drawMiddleArcSection=(e,t,i)=>{let r=this.circularBezierControlPoints(e.outer,t.outer,this.origin),o=this.circularBezierControlPoints(t.inner,e.inner,this.origin);i?this.context.bezierCurveTo(o.cp1.x,o.cp1.y,o.cp2.x,o.cp2.y,e.inner.x,e.inner.y):this.context.bezierCurveTo(r.cp1.x,r.cp1.y,r.cp2.x,r.cp2.y,t.outer.x,t.outer.y)};drawTailArcSection=(e,t,i)=>{let r=this.circularBezierControlPoints(e.outer,t.outer,this.origin),o=this.circularBezierControlPoints(t.inner,e.inner,this.origin);this.context.moveTo(t.inner.x,t.inner.y),this.context.bezierCurveTo(o.cp1.x,o.cp1.y,o.cp2.x,o.cp2.y,e.inner.x,e.inner.y),this.lineCap=="rounded"||this.tailCap=="rounded"?(this.ctxCircToVector(e.inner,i,e.mid),this.ctxCircToVector(i,e.outer,e.mid)):this.context.lineTo(e.outer.x,e.outer.y),this.context.bezierCurveTo(r.cp1.x,r.cp1.y,r.cp2.x,r.cp2.y,t.outer.x,t.outer.y)};drawTrack=()=>{this.trackColour&&(this.context.beginPath(),this.context.fillStyle=this.trackColour,this.context.arc(this.origin.x,this.origin.y,this.radius-1,0,Math.PI*2),this.context.arc(this.origin.x,this.origin.y,this.radius-this.arcWidth+1,0,Math.PI*2,!0),this.context.fill())};drawBorders=()=>{this.outerBorder&&(this.context.beginPath(),this.context.strokeStyle=this.outerBorder.colour,this.context.lineWidth=this.outerBorder.weight,this.context.arc(this.origin.x,this.origin.y,this.radius,0,Math.PI*2),this.context.stroke()),this.innerBorder&&(this.context.beginPath(),this.context.strokeStyle=this.innerBorder.colour,this.context.lineWidth=this.innerBorder.weight,this.context.arc(this.origin.x,this.origin.y,this.radius-this.arcWidth,0,Math.PI*2),this.context.stroke())};calculateOffsets=(e,t)=>{let i=this.radius-(this.arcs-(e+1))*this.radiusDelta*this.radius,r,o,s;if(this.arcAnchor=="centre")r=i-t/2,o=i-this.arcWidth+t/2,s=i-t/2-(this.arcWidth-t)/2;else if(this.arcAnchor=="inner")r=i-t,o=i-this.arcWidth,s=i-t-(this.arcWidth-t)/2;else if(this.arcAnchor=="outer")r=i,o=i-(this.arcWidth-t),s=i-(this.arcWidth-t)/2;else throw new Error("Invalid arcAnchor value: "+this.arcAnchor);return r=Math.max(r,0),o=Math.max(o,0),s=Math.max(s,0),{outer:r,inner:o,mid:s}};calculatePositions=(e,t,i,r)=>{let o=-1;e<2*Math.PI/3?o=0:e<4*Math.PI/3?o=1:o=2;let s=-1;t<2*Math.PI/3?s=0:t<4*Math.PI/3?s=1:s=2;let a={outer:{x:this.origin.x+i.outer*Math.cos(e),y:this.origin.y+i.outer*Math.sin(e)},inner:{x:this.origin.x+i.inner*Math.cos(e),y:this.origin.y+i.inner*Math.sin(e)},mid:{x:this.origin.x+i.mid*Math.cos(e),y:this.origin.y+i.mid*Math.sin(e)}},c=(this.arcWidth-r)/2,n=e>Math.PI?c:-c,u={x:1,y:-1/Math.tan(e)},l=Math.sqrt(Math.pow(u.x,2)+Math.pow(u.y,2)),x={x:u.x/l,y:u.y/l},g={x:this.origin.x+i.mid*Math.cos(e)+x.x*n,y:this.origin.y+i.mid*Math.sin(e)+x.y*n},p={outer:{x:this.origin.x+i.outer*Math.cos(t),y:this.origin.y+i.outer*Math.sin(t)},inner:{x:this.origin.x+i.inner*Math.cos(t),y:this.origin.y+i.inner*Math.sin(t)},mid:{x:this.origin.x+i.mid*Math.cos(t),y:this.origin.y+i.mid*Math.sin(t)}},T=t<Math.PI?c:-c,d={x:1,y:-1/Math.tan(t)},m=Math.sqrt(Math.pow(d.x,2)+Math.pow(d.y,2)),y={x:d.x/m,y:d.y/m},V={x:this.origin.x+i.mid*Math.cos(t)+y.x*T,y:this.origin.y+i.mid*Math.sin(t)+y.y*T},D=[{outer:{x:this.origin.x+i.outer*Math.cos(0),y:this.origin.y+i.outer*Math.sin(0)},inner:{x:this.origin.x+i.inner*Math.cos(0),y:this.origin.y+i.inner*Math.sin(0)},mid:{x:this.origin.x+i.mid*Math.cos(0),y:this.origin.y+i.mid*Math.sin(0)}},{outer:{x:this.origin.x+i.outer*Math.cos(2*Math.PI/3),y:this.origin.y+i.outer*Math.sin(2*Math.PI/3)},inner:{x:this.origin.x+i.inner*Math.cos(2*Math.PI/3),y:this.origin.y+i.inner*Math.sin(2*Math.PI/3)},mid:{x:this.origin.x+i.mid*Math.cos(2*Math.PI/3),y:this.origin.y+i.mid*Math.sin(2*Math.PI/3)}},{outer:{x:this.origin.x+i.outer*Math.cos(4*Math.PI/3),y:this.origin.y+i.outer*Math.sin(4*Math.PI/3)},inner:{x:this.origin.x+i.inner*Math.cos(4*Math.PI/3),y:this.origin.y+i.inner*Math.sin(4*Math.PI/3)},mid:{x:this.origin.x+i.mid*Math.cos(4*Math.PI/3),y:this.origin.y+i.mid*Math.sin(4*Math.PI/3)}}];return{lead:a,tail:p,leadSection:o,tailSection:s,leadGuide:g,tailGuide:V,sectionBounds:D}}};var L=class extends b{geometries;arcs;arcWidth;tailDelay;arcDelay;radius;xOff;mutator;radiusDelta;arcWidthDelta;constructor(e,t){super(e,t),this.arcs=t?.arcs??1,this.arcWidth=t?.arcWidth??10,this.arcWidthDelta=t?.arcWidthDelta??0,this.tailDelay=t?.tailDelay??.2,this.arcDelay=t?.arcDelay??.1,this.radius=t?.radius??this.canvas.width/8,this.radiusDelta=t?.radiusDelta??0,this.xOff=t?.xOff??this.radius*2,this.mutator=t?.mutator??(()=>{}),this.geometries=[];for(let i=0;i<this.arcs;i++){let r=this.deriveGeometry(this.radius-i*this.radiusDelta*this.radius,this.xOff);this.geometries.push(r)}}parentDraw=this.draw;deriveGeometry(e,t){let i=e*e,r=t*t,o=Math.sqrt(i/(r-i)),s=-1/o,a=o*o,c=4*r-4*(a+1)*(r-i),n=(2*t-Math.sqrt(c))/(2*(a+1)),h=o*n,u={x:n,y:h},l=Math.sqrt(n*n+h*h),x=Math.PI/2-Math.atan(h/n),g=x/Math.PI,p=2*Math.PI-x*2,T=e*2*Math.PI,w=g*T,d=l*.5,m=w,y=d+m+d*2+m+d,V=[0,d/y,(d+m/2)/y,(d+m)/y,(d+m+d)/y,(d+m+d*2)/y,(d+m+d*2+m/2)/y,(d+m+d*2+m)/y,(d+m+d*2+m+d)/y,1];return{k:o,k_orthogonal:s,tangent_point:u,theta:x,arc_theta:p,checkpoints:V}}mutate=()=>{this.mutator(this)};draw=()=>{this.parentDraw();for(let e=0;e<this.arcs;e++)this.drawArc(e)};drawArc=e=>{let t=this.getProgress(this.arcDelay*e),i=this.getProgress(this.arcDelay*e-this.tailDelay);this.ctxSetColour(this.arcs-e-1),this.context.beginPath();let r=this.arcPoints(e),o=this.getSection(t,e),s=this.getSection(i,e);if(s==o&&t>i){this.drawSection(s,"contained",r,e),this.ctxDraw();return}let c=s,n=this.geometries[e].checkpoints.length-2,h=!1,u=!1;for(let l=0;l<1e3&&!(c==s&&h);l++)c==s&&!u?(this.drawSection(c,"tail",r,e),u=!0):c==o?(this.drawSection(c,"lead",r,e),h=!0):h?this.drawSection(c,"inner-mid",r,e):this.drawSection(c,"outer-mid",r,e),c=h?(c+(n-1))%n:(c+1)%n;this.ctxDraw()};drawPath=()=>{this.ctxSetColour(-1),this.context.beginPath(),this.context.arc(this.origin.x,this.origin.y,1,0,2*Math.PI),this.context.stroke(),this.ctxSetColour(0),this.context.beginPath(),this.context.arc(this.origin.x+this.xOff,this.origin.y,this.radius,0,2*Math.PI),this.context.stroke(),this.context.beginPath(),this.context.arc(this.origin.x-this.xOff,this.origin.y,this.radius,0,2*Math.PI),this.context.stroke();let e=this.radius*this.radius,t=this.xOff*this.xOff,i=Math.sqrt(e/(t-e)),r=i*i,o=4*t-4*(r+1)*(t-e),s=(2*this.xOff-Math.sqrt(o))/(2*(r+1)),a={x:s,y:i*s},c={x:s,y:i*s*-1};this.ctxSetColour(3),this.context.beginPath(),this.context.moveTo(this.origin.x,this.origin.y),this.context.lineTo(this.origin.x+a.x,this.origin.y+a.y),this.context.stroke(),this.ctxSetColour(4),this.context.beginPath(),this.context.moveTo(this.origin.x,this.origin.y),this.context.lineTo(this.origin.x-a.x,this.origin.y-a.y),this.context.stroke(),this.ctxSetColour(6),this.context.beginPath(),this.context.moveTo(this.origin.x,this.origin.y),this.context.lineTo(this.origin.x+c.x,this.origin.y+c.y),this.context.stroke(),this.context.beginPath(),this.context.moveTo(this.origin.x,this.origin.y),this.context.lineTo(this.origin.x-c.x,this.origin.y-c.y),this.context.stroke()};arcPoints=e=>{let t=this.getProgress(this.arcDelay*e),i=this.getProgress(this.arcDelay*e-this.tailDelay),r=this.progressPosition(t,e),o=this.progressPosition(i,e);return{lead:r,tail:o}};progressPosition=(e,t)=>{let i={x:0,y:0},r={x:0,y:0},o={x:0,y:0},s=1-t*this.arcWidthDelta,a=this.radius-t*this.radiusDelta*this.radius;if(e<=this.geometries[t].checkpoints[1]){let n=e/this.geometries[t].checkpoints[1]*this.geometries[t].tangent_point.x*-1,h=n*this.geometries[t].k,u={x:n,y:h},l=Math.sqrt(this.arcWidth*this.arcWidth/(4*(1+this.geometries[t].k_orthogonal*this.geometries[t].k_orthogonal))),x=this.geometries[t].k_orthogonal*l;i={x:this.origin.x+u.x+l*s,y:this.origin.y+u.y+x*s},r={x:this.origin.x+n-l*s,y:this.origin.y+h-x*s},o={x:this.origin.x+n,y:this.origin.y+h}}else if(e<=this.geometries[t].checkpoints[3]){let c=(e-this.geometries[t].checkpoints[1])/(this.geometries[t].checkpoints[3]-this.geometries[t].checkpoints[1]),n=this.geometries[t].theta+c*this.geometries[t].arc_theta;o={x:this.origin.x+Math.cos(n)*a-this.xOff,y:this.origin.y+Math.sin(n)*a*-1},i={x:this.origin.x+Math.cos(n)*(a+this.arcWidth/2*s)-this.xOff,y:this.origin.y+Math.sin(n)*(a+this.arcWidth/2*s)*-1},r={x:this.origin.x+Math.cos(n)*(a-this.arcWidth/2*s)-this.xOff,y:this.origin.y+Math.sin(n)*(a-this.arcWidth/2*s)*-1}}else if(e<this.geometries[t].checkpoints[4]){let c=(e-this.geometries[t].checkpoints[3])/(this.geometries[t].checkpoints[4]-this.geometries[t].checkpoints[3]),n=-1*this.geometries[t].tangent_point.x+c*this.geometries[t].tangent_point.x,h=n*this.geometries[t].k*-1,u={x:n,y:h},l=Math.sqrt(this.arcWidth*this.arcWidth/(4*(1+this.geometries[t].k_orthogonal*this.geometries[t].k_orthogonal))),x=l*this.geometries[t].k_orthogonal*-1;i={x:this.origin.x+u.x+l*s,y:this.origin.y+u.y+x*s},r={x:this.origin.x+n-l*s,y:this.origin.y+h-x*s},o={x:this.origin.x+n,y:this.origin.y+h}}else if(e<=this.geometries[t].checkpoints[5]){let n=(e-this.geometries[t].checkpoints[4])/(this.geometries[t].checkpoints[5]-this.geometries[t].checkpoints[4])*this.geometries[t].tangent_point.x,h=n*this.geometries[t].k*-1,u={x:n,y:h},l=Math.sqrt(this.arcWidth*this.arcWidth/(4*(1+this.geometries[t].k_orthogonal*this.geometries[t].k_orthogonal))),x=l*this.geometries[t].k_orthogonal*-1;r={x:this.origin.x+u.x-l*s,y:this.origin.y+u.y-x*s},i={x:this.origin.x+n+l*s,y:this.origin.y+h+x*s},o={x:this.origin.x+n,y:this.origin.y+h}}else if(e<=this.geometries[t].checkpoints[7]){let c=(e-this.geometries[t].checkpoints[5])/(this.geometries[t].checkpoints[7]-this.geometries[t].checkpoints[5]),n=this.geometries[t].theta+c*this.geometries[t].arc_theta;o={x:this.origin.x+-1*Math.cos(n)*a+this.xOff,y:this.origin.y+Math.sin(n)*a*-1},r={x:this.origin.x+-1*Math.cos(n)*(a+this.arcWidth/2*s)+this.xOff,y:this.origin.y+Math.sin(n)*(a+this.arcWidth/2*s)*-1},i={x:this.origin.x+-1*Math.cos(n)*(a-this.arcWidth/2*s)+this.xOff,y:this.origin.y+Math.sin(n)*(a-this.arcWidth/2*s)*-1}}else{let c=(e-this.geometries[t].checkpoints[7])/(this.geometries[t].checkpoints[8]-this.geometries[t].checkpoints[7]),n=this.geometries[t].tangent_point.x-c*this.geometries[t].tangent_point.x,h=n*this.geometries[t].k,u={x:n,y:h},l=Math.sqrt(this.arcWidth*this.arcWidth/(4*(1+this.geometries[t].k_orthogonal*this.geometries[t].k_orthogonal))),x=this.geometries[t].k_orthogonal*l;r={x:this.origin.x+u.x+l*s,y:this.origin.y+u.y+x*s},i={x:this.origin.x+n-l*s,y:this.origin.y+h-x*s},o={x:this.origin.x+n,y:this.origin.y+h}}return{outer:i,inner:r,mid:o}};getSection=(e,t)=>{for(let i=0;i<this.geometries[t].checkpoints.length+1;i++)if(e>this.geometries[t].checkpoints[i]&&e<=this.geometries[t].checkpoints[i+1])return i;return-1};drawSection=(e,t,i,r)=>{switch(e){case 0:this.draw_NW_Line(t,i,r);break;case 1:this.draw_NW_Arc(t,i,r);break;case 2:this.draw_SW_Arc(t,i,r);break;case 3:this.draw_SW_Line(t,i,r);break;case 4:this.draw_NE_Line(t,i,r);break;case 5:this.draw_NE_Arc(t,i,r);break;case 6:this.draw_SE_Arc(t,i,r);break;case 7:this.draw_SE_Line(t,i,r);break;default:console.error("Tried to draw invalid section number: "+e);break}};draw_NW_Line=(e,t,i)=>{let r=this.progressPosition(this.geometries[i].checkpoints[0],i),o=this.progressPosition(this.geometries[i].checkpoints[1],i);switch(e){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(t.tail.inner);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxLineToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(o.outer);break;case"outer-mid":this.ctxLineToVector(o.outer);break;case"lead":this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(r.inner);break;case"inner-mid":this.ctxLineToVector(r.inner);break;default:console.error("Tried to draw section with invalid order: "+e)}};draw_NW_Arc=(e,t,i)=>{let r=this.progressPosition(this.geometries[i].checkpoints[1],i),o=this.progressPosition(this.geometries[i].checkpoints[2],i),s={x:this.origin.x-this.xOff,y:this.origin.y};switch(e){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,t.lead.outer,s),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,t.tail.inner,s);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxCircToVector(o.inner,t.tail.inner,s),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,o.outer,s);break;case"outer-mid":this.ctxCircToVector(r.outer,o.outer,s);break;case"lead":this.ctxCircToVector(r.outer,t.lead.outer,s),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,r.inner,s);break;case"inner-mid":this.ctxCircToVector(o.inner,r.inner,s);break;default:console.error("Tried to draw section with invalid order: "+e)}};draw_SW_Arc=(e,t,i)=>{let r=this.progressPosition(this.geometries[i].checkpoints[2],i),o=this.progressPosition(this.geometries[i].checkpoints[3],i),s={x:this.origin.x-this.xOff,y:this.origin.y};switch(e){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,t.lead.outer,s),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,t.tail.inner,s);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxCircToVector(o.inner,t.tail.inner,s),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,o.outer,s);break;case"outer-mid":this.ctxCircToVector(r.outer,o.outer,s);break;case"lead":this.ctxCircToVector(r.outer,t.lead.outer,s),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,r.inner,s);break;case"inner-mid":this.ctxCircToVector(o.inner,r.inner,s);break;default:console.error("Tried to draw section with invalid order: "+e)}};draw_SW_Line=(e,t,i)=>{let r=this.progressPosition(this.geometries[i].checkpoints[3],i),o=this.progressPosition(this.geometries[i].checkpoints[4],i);switch(e){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(t.tail.inner);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxLineToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(o.outer);break;case"outer-mid":this.ctxLineToVector(o.outer);break;case"lead":this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(r.inner);break;case"inner-mid":this.ctxLineToVector(r.inner);break;default:console.error("Tried to draw section with invalid order: "+e)}};draw_NE_Line=(e,t,i)=>{let r=this.progressPosition(this.geometries[i].checkpoints[4],i),o=this.progressPosition(this.geometries[i].checkpoints[5],i);switch(e){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(t.tail.inner);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxLineToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(o.outer);break;case"outer-mid":this.ctxLineToVector(o.outer);break;case"lead":this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(r.inner);break;case"inner-mid":this.ctxLineToVector(r.inner);break;default:console.error("Tried to draw section with invalid order: "+e)}};draw_NE_Arc=(e,t,i)=>{let r=this.progressPosition(this.geometries[i].checkpoints[5],i),o=this.progressPosition(this.geometries[i].checkpoints[6],i),s={x:this.origin.x+this.xOff,y:this.origin.y};switch(e){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,t.lead.outer,s),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,t.tail.inner,s);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxCircToVector(o.inner,t.tail.inner,s),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,o.outer,s);break;case"outer-mid":this.ctxCircToVector(r.outer,o.outer,s);break;case"lead":this.ctxCircToVector(r.outer,t.lead.outer,s),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,r.inner,s);break;case"inner-mid":this.ctxCircToVector(o.inner,r.inner,s);break;default:console.error("Tried to draw section with invalid order: "+e)}};draw_SE_Arc=(e,t,i)=>{let r=this.progressPosition(this.geometries[i].checkpoints[6],i),o=this.progressPosition(this.geometries[i].checkpoints[7],i),s={x:this.origin.x+this.xOff,y:this.origin.y};switch(e){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,t.lead.outer,s),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,t.tail.inner,s);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxCircToVector(o.inner,t.tail.inner,s),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,o.outer,s);break;case"outer-mid":this.ctxCircToVector(r.outer,o.outer,s);break;case"lead":this.ctxCircToVector(r.outer,t.lead.outer,s),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,r.inner,s);break;case"inner-mid":this.ctxCircToVector(o.inner,r.inner,s);break;default:console.error("Tried to draw section with invalid order: "+e)}};draw_SE_Line=(e,t,i)=>{let r=this.progressPosition(this.geometries[i].checkpoints[7],i),o=this.progressPosition(this.geometries[i].checkpoints[8],i);switch(e){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(t.tail.inner);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxLineToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(o.outer),this.ctxMoveToVector(o.inner);break;case"outer-mid":this.ctxLineToVector(o.inner);break;case"lead":this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(r.inner);break;case"inner-mid":this.ctxLineToVector(r.inner);break;default:console.error("Tried to draw section with invalid order: "+e)}}};var R=["disperse","coelesce","off"],S=class extends b{sideLength;circleSize;relativeExpansion;delay;mutator;alternateSpin;rotations;opacityPulse;radiusPulse;constructor(e,t){super(e,t);let i={style:"off",delay:.1,intensity:1};this.sideLength=t?.sideLength??3,this.circleSize=t?.circleSize??this.canvas.width/8,this.relativeExpansion=t?.relativeExpansion??1,this.delay=t?.delay??.1,this.alternateSpin=t?.alternateSpin??!1,this.drawStyle=t?.drawStyle??"stroke",this.mutator=t?.mutator??(()=>{}),this.rotations=t?.rotations??1,this.opacityPulse=t?.opacityPulse??structuredClone(i),this.radiusPulse=t?.radiusPulse??structuredClone(i)}parentDraw=this.draw;mutate=()=>{this.mutator(this)};draw=()=>{this.parentDraw();for(let e=this.sideLength-1;e>=0;e--){let t=this.getProgress(this.delay*e)*Math.PI*2*this.rotations;this.alternateSpin&&e%2==0&&(t*=-1),this.ctxSetColour(e),this.performOpacityPulse(e);let i=this.performRadiusPulse(e);for(let r=0;r<6;r++){let o=Math.PI/6+Math.PI/3*r,s=this.circleSize*this.relativeExpansion*e,a={x:this.origin.x+s*Math.cos(o+t),y:this.origin.y+s*Math.sin(o+t)};if(this.context.beginPath(),this.context.arc(a.x,a.y,i,0,Math.PI*2),this.ctxDraw(),e==0)break;for(let c=0;c<e-1;c++){let n={x:a.x+(c+1)*this.circleSize*this.relativeExpansion*Math.cos(o+2*Math.PI/3+t),y:a.y+(c+1)*this.circleSize*this.relativeExpansion*Math.sin(o+2*Math.PI/3+t)};this.context.beginPath(),this.context.arc(n.x,n.y,i,0,Math.PI*2),this.ctxDraw()}}}};performOpacityPulse=e=>{let t=e;if(this.opacityPulse.style=="coelesce"){let i=this.getProgressLinear(this.opacityPulse.delay*t);this.ctxModifyOpacity(i<.5?-(i*2):-2+i*2)}else if(this.opacityPulse.style=="disperse"){let i=this.getProgressLinear(this.opacityPulse.delay*(this.sideLength-1-t));this.ctxModifyOpacity(i<.5?-(i*2):-2+i*2)}};performRadiusPulse=e=>{let t=e,i=this.circleSize;if(this.radiusPulse.style=="coelesce"){let r=this.getProgressLinear(this.radiusPulse.delay*t),o=r<.5?-(r*2):-2+r*2;i=i+o*this.radiusPulse.intensity*i}else if(this.radiusPulse.style=="disperse"){let r=this.getProgressLinear(this.radiusPulse.delay*(this.sideLength-1-t)),o=r<.5?-(r*2):-2+r*2;i=i+o*this.radiusPulse.intensity*i}return i}};var G=["fill","stroke"],U=["linear","sinusoidal","quadratic","cubic","custom"],Y=["antiquum","lemniscate","sempiternal"],$=["inner","centre","outer"],j=["flat","rounded"];})();
