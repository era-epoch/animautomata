(function(){const a=document.createElement("link").relList;if(a&&a.supports&&a.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))l(i);new MutationObserver(i=>{for(const t of i)if(t.type==="childList")for(const e of t.addedNodes)e.tagName==="LINK"&&e.rel==="modulepreload"&&l(e)}).observe(document,{childList:!0,subtree:!0});function n(i){const t={};return i.integrity&&(t.integrity=i.integrity),i.referrerPolicy&&(t.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?t.credentials="include":i.crossOrigin==="anonymous"?t.credentials="omit":t.credentials="same-origin",t}function l(i){if(i.ep)return;i.ep=!0;const t=n(i);fetch(i.href,t)}})();const v=(p,a)=>(p%a+a)%a,F=()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,p=>{const a=Math.floor(Math.random()*16);return(p=="x"?a:a&3|8).toString(16)});class L{constructor(a){if(this.postConstructor=()=>{this.postConstructorCalls++,this.paused||requestAnimationFrame(this.animate)},this.setConfig=n=>{this.backgroundColour=n.backgroundColour??this.backgroundColour,this.currProgress=n.currProgress??this.currProgress,this.lastProgress=n.lastProgress??this.lastProgress,this.rest=n.rest??this.rest,this.fps=n.fps??this.fps,this.cycleDuration_ms=n.cycleDuration_ms??this.cycleDuration_ms,this.currIteration=n.currIteration??this.currIteration,this.nIterations=n.nIterations??this.nIterations,this.paused=n.paused??this.paused,this.colours=n.colours??this.colours,this.opacity=n.opacity??this.opacity,this.opacityDelta=n.opacityDelta??this.opacityDelta,this.timingFunction=n.timingFunction??this.timingFunction,this.customTimingFunction=n.customTimingFunction??this.customTimingFunction,this.drawStyle=n.drawStyle??this.drawStyle,this.canvas.width=n.canvasWidth??this.canvas.width,this.canvas.height=n.canvasHeight??this.canvas.height,this.origin={x:Math.floor(this.canvas.width/2),y:Math.floor(this.canvas.height/2)}},this.draw=()=>{this.context.clearRect(0,0,this.canvas.width,this.canvas.height);const l=1e3/this.fps/this.cycleDuration_ms;this.frame=Math.floor(this.currProgress/l),this.lastDraw=performance.now(),this.backgroundColour!=null&&(this.context.fillStyle=this.backgroundColour,this.context.fillRect(0,0,this.canvas.width,this.canvas.height))},this.step=()=>{this.seek(1)},this.seek=n=>{const i=1e3/this.fps/this.cycleDuration_ms;this.lastProgress=this.currProgress,this.currProgress=(1+this.currProgress+n*i)%1,this.lastProgress===1&&(this.currProgress=0),this.draw()},this.animate=()=>{if(this.paused)return;requestAnimationFrame(this.animate);const n=performance.now(),l=n-this.lastDraw,i=1e3/this.fps;l<i||(this.lastProgress=this.currProgress,this.currProgress=v(n-this.pauseDuration-this.start,this.cycleDuration_ms)/this.cycleDuration_ms,this.lastProgress>this.currProgress&&(this.currIteration++,this.currIteration>=this.nIterations&&this.pause()),this.draw())},this.getProgress=n=>{switch(this.timingFunction){case"sinusoidal":return this.getProgressSinusoidal(n);case"quadratic":return this.getProgressExponential(2,n);case"cubic":return this.getProgressExponential(3,n);case"custom":if(this.customTimingFunction==null)throw new Error("Custom timing function does not exist.");return this.customTimingFunction(n);default:return this.getProgressLinear(n)}},this.getProgressLinear=n=>{const l=n?(this.currProgress+1+n)%1:this.currProgress;return Math.min(1,l/(1-this.rest))},this.getProgressExponential=(n,l)=>{const i=l?(this.currProgress+1+l)%1:this.currProgress,t=Math.min(1,i/(1-this.rest));return Math.pow(t,n)},this.getProgressSinusoidal=n=>{const l=n?(this.currProgress+1+n)%1:this.currProgress,i=Math.min(1,l/(1-this.rest));return .5+Math.sin((i-.5)*Math.PI)/2},this.play=()=>{if(!this.paused)return;this.paused=!1;const n=performance.now();this.lastDraw=n,this.pauseDuration+=n-this.pauseTimestamp,requestAnimationFrame(this.animate)},this.pause=()=>{this.paused||(this.paused=!0,this.pauseTimestamp=performance.now())},this.ctxDraw=()=>{this.drawStyle=="fill"?this.context.fill():this.context.stroke()},this.ctxMoveToVector=n=>{this.context.moveTo(n.x,n.y)},this.ctxLineToVector=n=>{this.context.lineTo(n.x,n.y)},this.ctxCircToVector=(n,l,i)=>{const t=this.circularBezierControlPoints(n,l,i);this.context.bezierCurveTo(t.cp1.x,t.cp1.y,t.cp2.x,t.cp2.y,l.x,l.y)},this.ctxSetColour=n=>{const l=v(n,this.colours.length),t=Math.floor(Math.max(0,this.opacity-(this.colours.length-1-l)*this.opacityDelta)*255).toString(16).padStart(2,"0"),e=`${this.colours[l]}${t}`;this.context.strokeStyle=e,this.context.fillStyle=e,this.currColour=e},this.ctxModifyOpacity=n=>{const l=this.currColour,i=l.slice(0,7),t=l.slice(7,9),e=parseInt(t,16),o=Math.floor(e+e*n).toString(16).padStart(2,"0"),r=`${i}${o}`;this.context.strokeStyle=r,this.context.fillStyle=r,this.currColour=r},this.drawDot=n=>{this.context.beginPath(),this.context.arc(this.origin.x+n.x,this.origin.y+n.y,2,0,2*Math.PI),this.context.fill()},this.circularBezierControlPoints=(n,l,i)=>{const t=i??{x:0,y:0},e=n.x-t.x,s=n.y-t.y,o=l.x-t.x,r=l.y-t.y,d=e*e+s*s,h=d+e*o+s*r,c=4/3*(Math.sqrt(2*d*h)-h)/(e*r-s*o),u=t.x+e-c*s,g=t.y+s+c*e,x=t.x+o+c*r,m=t.y+r-c*o;return{cp1:{x:u,y:g},cp2:{x,y:m}}},window.isSecureContext?this.id=crypto.randomUUID():this.id=F(),this.postConstructorCalls=0,this.start=performance.now(),this.lastDraw=this.start,this.lastMutationTimestamp=this.start,this.pauseTimestamp=0,this.pauseDuration=0,this.canvas=document.getElementById(a),this.canvas===null)throw new Error("Canvas element not found with id: "+a);this.canvas.setAttribute("data-animautomata-id",this.id),this.origin={x:Math.floor(this.canvas.width/2),y:Math.floor(this.canvas.height/2)},this.currColour="",this.context=this.canvas.getContext("2d"),this.frame=0,this.backgroundColour=null,this.currProgress=0,this.lastProgress=0,this.rest=0,this.fps=60,this.cycleDuration_ms=1500,this.currIteration=0,this.nIterations=1/0,this.paused=!1,this.colours=["#000000"],this.opacity=1,this.opacityDelta=0,this.timingFunction="sinusoidal",this.customTimingFunction=this.getProgressLinear,this.drawStyle="fill"}}class I extends L{constructor(a,n){super(a),this.parentDraw=this.draw,this.parentSetConfig=this.setConfig,this.setConfig=i=>{this.parentSetConfig(i),this.arcs=i.arcs??this.arcs,this.arcWidth=i.arcWidth??this.arcWidth,this.arcWidthDelta=i.arcWidthDelta??this.arcWidthDelta,this.arcAnchor=i.arcAnchor??this.arcAnchor,this.tailDelay=i.tailDelay??this.tailDelay,this.arcDelay=i.arcDelay??this.arcDelay,this.radius=i.radius??this.radius,this.radiusDelta=i.radiusDelta??this.radiusDelta,this.rotations=i.rotations??this.rotations,this.innerBorder=i.innerBorder??this.innerBorder,this.outerBorder=i.outerBorder??this.outerBorder,this.trackColour=i.trackColour??this.trackColour,this.lineCap=i.lineCap??this.lineCap,this.leadCap=i.leadCap??this.leadCap,this.tailCap=i.tailCap??this.tailCap},this.getAccumulatedRotation=()=>(this.currIteration+this.currProgress)*this.rotations*Math.PI*2,this.draw=()=>{this.parentDraw();const i=this.getAccumulatedRotation();this.drawTrack();for(let t=0;t<this.arcs;t++){const e=v(this.getProgress(this.arcDelay*t)*Math.PI*2+i,Math.PI*2),s=v(this.getProgress(this.arcDelay*t-this.tailDelay)*Math.PI*2+i,Math.PI*2),o=(this.arcs-(t+1))*this.arcWidthDelta*this.arcWidth,r=this.calculateOffsets(t,o),{lead:d,tail:h,leadSection:c,tailSection:u,leadGuide:g,tailGuide:x,sectionBounds:m}=this.calculatePositions(e,s,r,o);this.ctxSetColour(this.arcs-t-1),this.context.beginPath();let P=u,y=!1,f=!1;for(let w=0;w<6;w++){if(u==P&&c==P&&e>s){this.drawContainedArc(h,d,g,x);break}else{if(u==P&&y)break;if(u==P&&!f){f=!0;const M=m[(P+1)%3];this.drawTailArcSection(h,M,x)}else if(c==P){y=!0;const M=m[P];this.drawLeadArcSection(d,M,g)}else{const M=m[P],V=m[(P+1)%3];this.drawMiddleArcSection(M,V,y)}}P=y?(P+2)%3:(P+1)%3}this.ctxDraw()}this.drawBorders()},this.drawContainedArc=(i,t,e,s)=>{const o=this.circularBezierControlPoints(i.outer,t.outer,this.origin),r=this.circularBezierControlPoints(t.inner,i.inner,this.origin);this.context.moveTo(t.inner.x,t.inner.y),this.context.bezierCurveTo(r.cp1.x,r.cp1.y,r.cp2.x,r.cp2.y,i.inner.x,i.inner.y),this.lineCap=="rounded"||this.tailCap=="rounded"?(this.ctxCircToVector(i.inner,s,i.mid),this.ctxCircToVector(s,i.outer,i.mid)):this.context.lineTo(i.outer.x,i.outer.y),this.context.bezierCurveTo(o.cp1.x,o.cp1.y,o.cp2.x,o.cp2.y,t.outer.x,t.outer.y),this.lineCap=="rounded"||this.leadCap=="rounded"?(this.ctxCircToVector(t.outer,e,t.mid),this.ctxCircToVector(e,t.inner,t.mid)):this.context.lineTo(t.inner.x,t.inner.y)},this.drawLeadArcSection=(i,t,e)=>{const s=this.circularBezierControlPoints(t.outer,i.outer,this.origin),o=this.circularBezierControlPoints(i.inner,t.inner,this.origin);this.context.bezierCurveTo(s.cp1.x,s.cp1.y,s.cp2.x,s.cp2.y,i.outer.x,i.outer.y),this.lineCap=="rounded"||this.leadCap=="rounded"?(this.ctxCircToVector(i.outer,e,i.mid),this.ctxCircToVector(e,i.inner,i.mid)):this.context.lineTo(i.inner.x,i.inner.y),this.context.bezierCurveTo(o.cp1.x,o.cp1.y,o.cp2.x,o.cp2.y,t.inner.x,t.inner.y)},this.drawMiddleArcSection=(i,t,e)=>{const s=this.circularBezierControlPoints(i.outer,t.outer,this.origin),o=this.circularBezierControlPoints(t.inner,i.inner,this.origin);e?this.context.bezierCurveTo(o.cp1.x,o.cp1.y,o.cp2.x,o.cp2.y,i.inner.x,i.inner.y):this.context.bezierCurveTo(s.cp1.x,s.cp1.y,s.cp2.x,s.cp2.y,t.outer.x,t.outer.y)},this.drawTailArcSection=(i,t,e)=>{const s=this.circularBezierControlPoints(i.outer,t.outer,this.origin),o=this.circularBezierControlPoints(t.inner,i.inner,this.origin);this.context.moveTo(t.inner.x,t.inner.y),this.context.bezierCurveTo(o.cp1.x,o.cp1.y,o.cp2.x,o.cp2.y,i.inner.x,i.inner.y),this.lineCap=="rounded"||this.tailCap=="rounded"?(this.ctxCircToVector(i.inner,e,i.mid),this.ctxCircToVector(e,i.outer,i.mid)):this.context.lineTo(i.outer.x,i.outer.y),this.context.bezierCurveTo(s.cp1.x,s.cp1.y,s.cp2.x,s.cp2.y,t.outer.x,t.outer.y)},this.drawTrack=()=>{this.trackColour&&(this.context.beginPath(),this.context.fillStyle=this.trackColour,this.context.arc(this.origin.x,this.origin.y,this.radius-1,0,Math.PI*2),this.context.arc(this.origin.x,this.origin.y,this.radius-this.arcWidth+1,0,Math.PI*2,!0),this.context.fill())},this.drawBorders=()=>{this.outerBorder&&(this.context.beginPath(),this.context.strokeStyle=this.outerBorder.colour,this.context.lineWidth=this.outerBorder.weight,this.context.arc(this.origin.x,this.origin.y,this.radius,0,Math.PI*2),this.context.stroke()),this.innerBorder&&(this.context.beginPath(),this.context.strokeStyle=this.innerBorder.colour,this.context.lineWidth=this.innerBorder.weight,this.context.arc(this.origin.x,this.origin.y,this.radius-this.arcWidth,0,Math.PI*2),this.context.stroke())},this.calculateOffsets=(i,t)=>{const e=this.radius-(this.arcs-(i+1))*this.radiusDelta*this.radius;let s,o,r;if(this.arcAnchor=="centre")s=e-t/2,o=e-this.arcWidth+t/2,r=e-t/2-(this.arcWidth-t)/2;else if(this.arcAnchor=="inner")s=e-t,o=e-this.arcWidth,r=e-t-(this.arcWidth-t)/2;else if(this.arcAnchor=="outer")s=e,o=e-(this.arcWidth-t),r=e-(this.arcWidth-t)/2;else throw new Error("Invalid arcAnchor value: "+this.arcAnchor);return s=Math.max(s,0),o=Math.max(o,0),r=Math.max(r,0),{outer:s,inner:o,mid:r}},this.calculatePositions=(i,t,e,s)=>{let o=-1;i<2*Math.PI/3?o=0:i<4*Math.PI/3?o=1:o=2;let r=-1;t<2*Math.PI/3?r=0:t<4*Math.PI/3?r=1:r=2;const d={outer:{x:this.origin.x+e.outer*Math.cos(i),y:this.origin.y+e.outer*Math.sin(i)},inner:{x:this.origin.x+e.inner*Math.cos(i),y:this.origin.y+e.inner*Math.sin(i)},mid:{x:this.origin.x+e.mid*Math.cos(i),y:this.origin.y+e.mid*Math.sin(i)}},h=(this.arcWidth-s)/2,c=i>Math.PI?h:-h,g={x:1,y:-1/Math.tan(i)},x=Math.sqrt(Math.pow(g.x,2)+Math.pow(g.y,2)),m={x:g.x/x,y:g.y/x},P={x:this.origin.x+e.mid*Math.cos(i)+m.x*c,y:this.origin.y+e.mid*Math.sin(i)+m.y*c},y={outer:{x:this.origin.x+e.outer*Math.cos(t),y:this.origin.y+e.outer*Math.sin(t)},inner:{x:this.origin.x+e.inner*Math.cos(t),y:this.origin.y+e.inner*Math.sin(t)},mid:{x:this.origin.x+e.mid*Math.cos(t),y:this.origin.y+e.mid*Math.sin(t)}},f=t<Math.PI?h:-h,T={x:1,y:-1/Math.tan(t)},M=Math.sqrt(Math.pow(T.x,2)+Math.pow(T.y,2)),V={x:T.x/M,y:T.y/M},b={x:this.origin.x+e.mid*Math.cos(t)+V.x*f,y:this.origin.y+e.mid*Math.sin(t)+V.y*f},_=[{outer:{x:this.origin.x+e.outer*Math.cos(0),y:this.origin.y+e.outer*Math.sin(0)},inner:{x:this.origin.x+e.inner*Math.cos(0),y:this.origin.y+e.inner*Math.sin(0)},mid:{x:this.origin.x+e.mid*Math.cos(0),y:this.origin.y+e.mid*Math.sin(0)}},{outer:{x:this.origin.x+e.outer*Math.cos(2*Math.PI/3),y:this.origin.y+e.outer*Math.sin(2*Math.PI/3)},inner:{x:this.origin.x+e.inner*Math.cos(2*Math.PI/3),y:this.origin.y+e.inner*Math.sin(2*Math.PI/3)},mid:{x:this.origin.x+e.mid*Math.cos(2*Math.PI/3),y:this.origin.y+e.mid*Math.sin(2*Math.PI/3)}},{outer:{x:this.origin.x+e.outer*Math.cos(4*Math.PI/3),y:this.origin.y+e.outer*Math.sin(4*Math.PI/3)},inner:{x:this.origin.x+e.inner*Math.cos(4*Math.PI/3),y:this.origin.y+e.inner*Math.sin(4*Math.PI/3)},mid:{x:this.origin.x+e.mid*Math.cos(4*Math.PI/3),y:this.origin.y+e.mid*Math.sin(4*Math.PI/3)}}];return{lead:d,tail:y,leadSection:o,tailSection:r,leadGuide:P,tailGuide:b,sectionBounds:_}},this.arcs=1,this.arcWidth=10,this.arcWidthDelta=.02,this.arcAnchor="centre",this.tailDelay=.25,this.arcDelay=.1;const l=Math.min(this.canvas.width,this.canvas.height,n?.canvasHeight??1/0,n?.canvasWidth??1/0);this.radius=Math.floor(l*.4),this.radiusDelta=0,this.rotations=1,this.innerBorder=null,this.outerBorder=null,this.trackColour="",this.lineCap="rounded",this.leadCap=null,this.tailCap=null,n&&this.setConfig(n),this.postConstructor()}}class W extends L{constructor(a,n){super(a),this.parentDraw=this.draw,this.parentSetConfig=this.setConfig,this.setConfig=i=>{this.parentSetConfig(i),this.arcs=i?.arcs??this.arcs,this.arcWidth=i?.arcWidth??this.arcWidth,this.arcWidthDelta=i?.arcWidthDelta??this.arcWidthDelta,this.tailDelay=i?.tailDelay??this.tailDelay,this.arcDelay=i?.arcDelay??this.arcDelay,this.radius=i?.radius??this.radius,this.radiusDelta=i?.radiusDelta??this.radiusDelta,this.xOff=i?.xOff??this.xOff,this.geometries=[];for(let t=0;t<this.arcs;t++){const e=this.deriveGeometry(this.radius-t*this.radiusDelta*this.radius,this.xOff);this.geometries.push(e)}},this.draw=()=>{this.parentDraw();for(let i=0;i<this.arcs;i++)this.drawArc(i)},this.drawArc=i=>{let t=this.getProgress(this.arcDelay*i),e=this.getProgress(this.arcDelay*i-this.tailDelay);(t==1||t==0)&&(t=1e-4),(e==1||e==0)&&(e=1e-4),this.ctxSetColour(this.arcs-i-1),this.context.beginPath();const s=this.arcPoints(i),o=this.getSection(t,i),r=this.getSection(e,i);if(r==o&&t>e){this.drawSection(r,"contained",s,i),this.ctxDraw();return}let h=r;const c=this.geometries[i].checkpoints.length-2;let u=!1,g=!1;for(let x=0;x<1e3&&!(h==r&&u);x++)h==r&&!g?(this.drawSection(h,"tail",s,i),g=!0):h==o?(this.drawSection(h,"lead",s,i),u=!0):u?this.drawSection(h,"inner-mid",s,i):this.drawSection(h,"outer-mid",s,i),h=u?(h+(c-1))%c:(h+1)%c;this.ctxDraw()},this.drawPath=()=>{this.ctxSetColour(-1),this.context.beginPath(),this.context.arc(this.origin.x,this.origin.y,1,0,2*Math.PI),this.context.stroke(),this.ctxSetColour(0),this.context.beginPath(),this.context.arc(this.origin.x+this.xOff,this.origin.y,this.radius,0,2*Math.PI),this.context.stroke(),this.context.beginPath(),this.context.arc(this.origin.x-this.xOff,this.origin.y,this.radius,0,2*Math.PI),this.context.stroke();const i=this.radius*this.radius,t=this.xOff*this.xOff,e=Math.sqrt(i/(t-i)),s=e*e,o=4*t-4*(s+1)*(t-i),r=(2*this.xOff-Math.sqrt(o))/(2*(s+1)),d={x:r,y:e*r},h={x:r,y:e*r*-1};this.ctxSetColour(3),this.context.beginPath(),this.context.moveTo(this.origin.x,this.origin.y),this.context.lineTo(this.origin.x+d.x,this.origin.y+d.y),this.context.stroke(),this.ctxSetColour(4),this.context.beginPath(),this.context.moveTo(this.origin.x,this.origin.y),this.context.lineTo(this.origin.x-d.x,this.origin.y-d.y),this.context.stroke(),this.ctxSetColour(6),this.context.beginPath(),this.context.moveTo(this.origin.x,this.origin.y),this.context.lineTo(this.origin.x+h.x,this.origin.y+h.y),this.context.stroke(),this.context.beginPath(),this.context.moveTo(this.origin.x,this.origin.y),this.context.lineTo(this.origin.x-h.x,this.origin.y-h.y),this.context.stroke()},this.arcPoints=i=>{const t=this.getProgress(this.arcDelay*i),e=this.getProgress(this.arcDelay*i-this.tailDelay),s=this.progressPosition(t,i),o=this.progressPosition(e,i);return{lead:s,tail:o}},this.progressPosition=(i,t)=>{let e={x:0,y:0},s={x:0,y:0},o={x:0,y:0};const r=1-t*this.arcWidthDelta,d=this.radius-t*this.radiusDelta*this.radius;if(i<=this.geometries[t].checkpoints[1]){const c=i/this.geometries[t].checkpoints[1]*this.geometries[t].tangent_point.x*-1,u=c*this.geometries[t].k,g={x:c,y:u},x=Math.sqrt(this.arcWidth*this.arcWidth/(4*(1+this.geometries[t].k_orthogonal*this.geometries[t].k_orthogonal))),m=this.geometries[t].k_orthogonal*x;e={x:this.origin.x+g.x+x*r,y:this.origin.y+g.y+m*r},s={x:this.origin.x+c-x*r,y:this.origin.y+u-m*r},o={x:this.origin.x+c,y:this.origin.y+u}}else if(i<=this.geometries[t].checkpoints[3]){const h=(i-this.geometries[t].checkpoints[1])/(this.geometries[t].checkpoints[3]-this.geometries[t].checkpoints[1]),c=this.geometries[t].theta+h*this.geometries[t].arc_theta;o={x:this.origin.x+Math.cos(c)*d-this.xOff,y:this.origin.y+Math.sin(c)*d*-1},e={x:this.origin.x+Math.cos(c)*(d+this.arcWidth/2*r)-this.xOff,y:this.origin.y+Math.sin(c)*(d+this.arcWidth/2*r)*-1},s={x:this.origin.x+Math.cos(c)*(d-this.arcWidth/2*r)-this.xOff,y:this.origin.y+Math.sin(c)*(d-this.arcWidth/2*r)*-1}}else if(i<this.geometries[t].checkpoints[4]){const h=(i-this.geometries[t].checkpoints[3])/(this.geometries[t].checkpoints[4]-this.geometries[t].checkpoints[3]),c=-1*this.geometries[t].tangent_point.x+h*this.geometries[t].tangent_point.x,u=c*this.geometries[t].k*-1,g={x:c,y:u},x=Math.sqrt(this.arcWidth*this.arcWidth/(4*(1+this.geometries[t].k_orthogonal*this.geometries[t].k_orthogonal))),m=x*this.geometries[t].k_orthogonal*-1;e={x:this.origin.x+g.x+x*r,y:this.origin.y+g.y+m*r},s={x:this.origin.x+c-x*r,y:this.origin.y+u-m*r},o={x:this.origin.x+c,y:this.origin.y+u}}else if(i<=this.geometries[t].checkpoints[5]){const c=(i-this.geometries[t].checkpoints[4])/(this.geometries[t].checkpoints[5]-this.geometries[t].checkpoints[4])*this.geometries[t].tangent_point.x,u=c*this.geometries[t].k*-1,g={x:c,y:u},x=Math.sqrt(this.arcWidth*this.arcWidth/(4*(1+this.geometries[t].k_orthogonal*this.geometries[t].k_orthogonal))),m=x*this.geometries[t].k_orthogonal*-1;s={x:this.origin.x+g.x-x*r,y:this.origin.y+g.y-m*r},e={x:this.origin.x+c+x*r,y:this.origin.y+u+m*r},o={x:this.origin.x+c,y:this.origin.y+u}}else if(i<=this.geometries[t].checkpoints[7]){const h=(i-this.geometries[t].checkpoints[5])/(this.geometries[t].checkpoints[7]-this.geometries[t].checkpoints[5]),c=this.geometries[t].theta+h*this.geometries[t].arc_theta;o={x:this.origin.x+-1*Math.cos(c)*d+this.xOff,y:this.origin.y+Math.sin(c)*d*-1},s={x:this.origin.x+-1*Math.cos(c)*(d+this.arcWidth/2*r)+this.xOff,y:this.origin.y+Math.sin(c)*(d+this.arcWidth/2*r)*-1},e={x:this.origin.x+-1*Math.cos(c)*(d-this.arcWidth/2*r)+this.xOff,y:this.origin.y+Math.sin(c)*(d-this.arcWidth/2*r)*-1}}else{const h=(i-this.geometries[t].checkpoints[7])/(this.geometries[t].checkpoints[8]-this.geometries[t].checkpoints[7]),c=this.geometries[t].tangent_point.x-h*this.geometries[t].tangent_point.x,u=c*this.geometries[t].k,g={x:c,y:u},x=Math.sqrt(this.arcWidth*this.arcWidth/(4*(1+this.geometries[t].k_orthogonal*this.geometries[t].k_orthogonal))),m=this.geometries[t].k_orthogonal*x;s={x:this.origin.x+g.x+x*r,y:this.origin.y+g.y+m*r},e={x:this.origin.x+c-x*r,y:this.origin.y+u-m*r},o={x:this.origin.x+c,y:this.origin.y+u}}return{outer:e,inner:s,mid:o}},this.getSection=(i,t)=>{for(let e=0;e<this.geometries[t].checkpoints.length+1;e++)if(i>this.geometries[t].checkpoints[e]&&i<=this.geometries[t].checkpoints[e+1])return e;return-1},this.drawSection=(i,t,e,s)=>{switch(i){case 0:this.draw_NW_Line(t,e,s);break;case 1:this.draw_NW_Arc(t,e,s);break;case 2:this.draw_SW_Arc(t,e,s);break;case 3:this.draw_SW_Line(t,e,s);break;case 4:this.draw_NE_Line(t,e,s);break;case 5:this.draw_NE_Arc(t,e,s);break;case 6:this.draw_SE_Arc(t,e,s);break;case 7:this.draw_SE_Line(t,e,s);break}},this.draw_NW_Line=(i,t,e)=>{const s=this.progressPosition(this.geometries[e].checkpoints[0],e),o=this.progressPosition(this.geometries[e].checkpoints[1],e);switch(i){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(t.tail.inner);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxLineToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(o.outer);break;case"outer-mid":this.ctxLineToVector(o.outer);break;case"lead":this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(s.inner);break;case"inner-mid":this.ctxLineToVector(s.inner);break;default:console.error("Tried to draw section with invalid order: "+i)}},this.draw_NW_Arc=(i,t,e)=>{const s=this.progressPosition(this.geometries[e].checkpoints[1],e),o=this.progressPosition(this.geometries[e].checkpoints[2],e),r={x:this.origin.x-this.xOff,y:this.origin.y};switch(i){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,t.lead.outer,r),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,t.tail.inner,r);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxCircToVector(o.inner,t.tail.inner,r),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,o.outer,r);break;case"outer-mid":this.ctxCircToVector(s.outer,o.outer,r);break;case"lead":this.ctxCircToVector(s.outer,t.lead.outer,r),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,s.inner,r);break;case"inner-mid":this.ctxCircToVector(o.inner,s.inner,r);break;default:console.error("Tried to draw section with invalid order: "+i)}},this.draw_SW_Arc=(i,t,e)=>{const s=this.progressPosition(this.geometries[e].checkpoints[2],e),o=this.progressPosition(this.geometries[e].checkpoints[3],e),r={x:this.origin.x-this.xOff,y:this.origin.y};switch(i){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,t.lead.outer,r),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,t.tail.inner,r);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxCircToVector(o.inner,t.tail.inner,r),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,o.outer,r);break;case"outer-mid":this.ctxCircToVector(s.outer,o.outer,r);break;case"lead":this.ctxCircToVector(s.outer,t.lead.outer,r),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,s.inner,r);break;case"inner-mid":this.ctxCircToVector(o.inner,s.inner,r);break;default:console.error("Tried to draw section with invalid order: "+i)}},this.draw_SW_Line=(i,t,e)=>{const s=this.progressPosition(this.geometries[e].checkpoints[3],e),o=this.progressPosition(this.geometries[e].checkpoints[4],e);switch(i){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(t.tail.inner);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxLineToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(o.outer);break;case"outer-mid":this.ctxLineToVector(o.outer);break;case"lead":this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(s.inner);break;case"inner-mid":this.ctxLineToVector(s.inner);break;default:console.error("Tried to draw section with invalid order: "+i)}},this.draw_NE_Line=(i,t,e)=>{const s=this.progressPosition(this.geometries[e].checkpoints[4],e),o=this.progressPosition(this.geometries[e].checkpoints[5],e);switch(i){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(t.tail.inner);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxLineToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(o.outer);break;case"outer-mid":this.ctxLineToVector(o.outer);break;case"lead":this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(s.inner);break;case"inner-mid":this.ctxLineToVector(s.inner);break;default:console.error("Tried to draw section with invalid order: "+i)}},this.draw_NE_Arc=(i,t,e)=>{const s=this.progressPosition(this.geometries[e].checkpoints[5],e),o=this.progressPosition(this.geometries[e].checkpoints[6],e),r={x:this.origin.x+this.xOff,y:this.origin.y};switch(i){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,t.lead.outer,r),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,t.tail.inner,r);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxCircToVector(o.inner,t.tail.inner,r),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,o.outer,r);break;case"outer-mid":this.ctxCircToVector(s.outer,o.outer,r);break;case"lead":this.ctxCircToVector(s.outer,t.lead.outer,r),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,s.inner,r);break;case"inner-mid":this.ctxCircToVector(o.inner,s.inner,r);break;default:console.error("Tried to draw section with invalid order: "+i)}},this.draw_SE_Arc=(i,t,e)=>{const s=this.progressPosition(this.geometries[e].checkpoints[6],e),o=this.progressPosition(this.geometries[e].checkpoints[7],e),r={x:this.origin.x+this.xOff,y:this.origin.y};switch(i){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,t.lead.outer,r),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,t.tail.inner,r);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxCircToVector(o.inner,t.tail.inner,r),this.ctxLineToVector(t.tail.outer),this.ctxCircToVector(t.tail.outer,o.outer,r);break;case"outer-mid":this.ctxCircToVector(s.outer,o.outer,r);break;case"lead":this.ctxCircToVector(s.outer,t.lead.outer,r),this.ctxLineToVector(t.lead.inner),this.ctxCircToVector(t.lead.inner,s.inner,r);break;case"inner-mid":this.ctxCircToVector(o.inner,s.inner,r);break;default:console.error("Tried to draw section with invalid order: "+i)}},this.draw_SE_Line=(i,t,e)=>{const s=this.progressPosition(this.geometries[e].checkpoints[7],e),o=this.progressPosition(this.geometries[e].checkpoints[8],e);switch(i){case"contained":this.ctxMoveToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(t.tail.inner);break;case"tail":this.ctxMoveToVector(o.inner),this.ctxLineToVector(t.tail.inner),this.ctxLineToVector(t.tail.outer),this.ctxLineToVector(o.outer),this.ctxMoveToVector(o.inner);break;case"outer-mid":this.ctxLineToVector(o.inner);break;case"lead":this.ctxLineToVector(t.lead.inner),this.ctxLineToVector(t.lead.outer),this.ctxLineToVector(s.inner);break;case"inner-mid":this.ctxLineToVector(s.inner);break;default:console.error("Tried to draw section with invalid order: "+i)}},this.arcs=1,this.arcWidth=10,this.arcWidthDelta=0,this.tailDelay=.2,this.arcDelay=.1;const l=Math.min(this.canvas.width,this.canvas.height,n?.canvasHeight??1/0,n?.canvasWidth??1/0);this.radius=l/8,this.radiusDelta=0,this.xOff=this.radius*2,this.geometries=[];for(let i=0;i<this.arcs;i++){const t=this.deriveGeometry(this.radius-i*this.radiusDelta*this.radius,this.xOff);this.geometries.push(t)}n&&this.setConfig(n),this.postConstructor()}deriveGeometry(a,n){const l=a*a,i=n*n,t=Math.sqrt(l/(i-l)),e=-1/t,s=t*t,o=4*i-4*(s+1)*(i-l),r=(2*n-Math.sqrt(o))/(2*(s+1)),d=t*r,h={x:r,y:d},c=Math.sqrt(r*r+d*d),u=Math.PI/2-Math.atan(d/r),g=u/Math.PI,x=2*Math.PI-u*2,m=a*2*Math.PI,P=g*m,y=c*.5,f=P,w=y+f+y*2+f+y,T=[0,y/w,(y+f/2)/w,(y+f)/w,(y+f+y)/w,(y+f+y*2)/w,(y+f+y*2+f/2)/w,(y+f+y*2+f)/w,(y+f+y*2+f+y)/w,1];return{k:t,k_orthogonal:e,tangent_point:h,theta:u,arc_theta:x,checkpoints:T}}}class E extends L{constructor(a,n){super(a),this.parentDraw=this.draw,this.parentSetConfig=this.setConfig,this.setConfig=t=>{this.parentSetConfig(t),this.sideLength=t?.sideLength??this.sideLength,this.circleSize=t?.circleSize??this.circleSize,this.relativeExpansion=t?.relativeExpansion??this.relativeExpansion,this.delay=t?.delay??this.delay,this.alternateSpin=t?.alternateSpin??this.alternateSpin,this.drawStyle=t?.drawStyle??this.drawStyle,this.rotations=t?.rotations??this.rotations,this.opacityPulse=t?.opacityPulse??this.opacityPulse,this.radiusPulse=t?.radiusPulse??this.radiusPulse},this.draw=()=>{this.parentDraw();for(let t=this.sideLength-1;t>=0;t--){let e=this.getProgress(this.delay*t)*Math.PI*2*this.rotations;this.alternateSpin&&t%2==0&&(e*=-1),this.ctxSetColour(t),this.performOpacityPulse(t);const s=this.performRadiusPulse(t);for(let o=0;o<6;o++){const r=Math.PI/6+Math.PI/3*o,d=this.circleSize*this.relativeExpansion*t,h={x:this.origin.x+d*Math.cos(r+e),y:this.origin.y+d*Math.sin(r+e)};if(this.context.beginPath(),this.context.arc(h.x,h.y,s,0,Math.PI*2),this.ctxDraw(),t==0)break;for(let c=0;c<t-1;c++){const u={x:h.x+(c+1)*this.circleSize*this.relativeExpansion*Math.cos(r+2*Math.PI/3+e),y:h.y+(c+1)*this.circleSize*this.relativeExpansion*Math.sin(r+2*Math.PI/3+e)};this.context.beginPath(),this.context.arc(u.x,u.y,s,0,Math.PI*2),this.ctxDraw()}}}},this.performOpacityPulse=t=>{const e=t;if(this.opacityPulse.style=="coelesce"){const s=this.getProgressLinear(this.opacityPulse.delay*e);this.ctxModifyOpacity(s<.5?-(s*2):-2+s*2)}else if(this.opacityPulse.style=="disperse"){const s=this.getProgressLinear(this.opacityPulse.delay*(this.sideLength-1-e));this.ctxModifyOpacity(s<.5?-(s*2):-2+s*2)}},this.performRadiusPulse=t=>{const e=t;let s=this.circleSize;if(this.radiusPulse.style=="coelesce"){const o=this.getProgressLinear(this.radiusPulse.delay*e),r=o<.5?-(o*2):-2+o*2;s=s+r*this.radiusPulse.intensity*s}else if(this.radiusPulse.style=="disperse"){const o=this.getProgressLinear(this.radiusPulse.delay*(this.sideLength-1-e)),r=o<.5?-(o*2):-2+o*2;s=s+r*this.radiusPulse.intensity*s}return s};const l={style:"off",delay:.1,intensity:1};this.sideLength=3;const i=Math.min(this.canvas.width,this.canvas.height,n?.canvasHeight??1/0,n?.canvasWidth??1/0);this.circleSize=i/8,this.relativeExpansion=1,this.delay=.1,this.alternateSpin=!1,this.drawStyle="stroke",this.rotations=1,this.opacityPulse=structuredClone(l),this.radiusPulse=structuredClone(l),n&&this.setConfig(n),this.postConstructor()}}const S=p=>{const a=document.getElementById("animations"),n=document.createElement("div");n.classList.add("animation-example");const l=document.createElement("h1");l.innerHTML=p;const i=document.createElement("canvas");return i.width=250,i.height=250,i.id=p+"-"+Math.floor(Math.random()*1e5),n.appendChild(l),n.appendChild(i),a?.appendChild(n),i.id},C=p=>{const a=new I(S("antiquum"),p);a.seek(0),a.pause();const n=document.querySelector(`[data-animautomata-id="${a.id}"]`);n!=null&&(n.parentElement.addEventListener("mouseenter",()=>a.play()),n.parentElement.addEventListener("mouseleave",()=>a.pause()))},k=p=>{const a=new W(S("lemniscate"),p);a.seek(0),a.pause();const n=document.querySelector(`[data-animautomata-id="${a.id}"]`);n!=null&&(n.parentElement.addEventListener("mouseenter",()=>a.play()),n.parentElement.addEventListener("mouseleave",()=>a.pause()))},D=p=>{const a=new E(S("sempiternal"),p);a.seek(0),a.pause();const n=document.querySelector(`[data-animautomata-id="${a.id}"]`);n!=null&&(n.parentElement.addEventListener("mouseenter",()=>a.play()),n.parentElement.addEventListener("mouseleave",()=>a.pause()))};C({radius:40});C({cycleDuration_ms:1500,fps:120,colours:["#FFc300","#ff5733","#c70039","#900C3F","#581845"],opacity:1,timingFunction:"sinusoidal",drawStyle:"fill",arcs:5,arcWidth:10,arcWidthDelta:.02,arcAnchor:"centre",tailDelay:.2,arcDelay:.05,radius:50,rotations:1,backgroundColour:"#020035"});C({cycleDuration_ms:2e3,fps:120,colours:["#FF6080","#D95DFF","#CC52C9","#733C80","#402E4D"],opacity:1,timingFunction:"sinusoidal",drawStyle:"fill",arcs:5,arcWidth:10,arcWidthDelta:-.69,arcAnchor:"centre",tailDelay:.18,arcDelay:.05,radius:94,rotations:2});C({cycleDuration_ms:2500,fps:120,colours:["#00ff9f","#00b8ff","#001eff","#bd00ff","#d600ff"],opacity:1,timingFunction:"sinusoidal",drawStyle:"fill",arcs:9,arcWidth:10,arcWidthDelta:-.69,arcAnchor:"centre",tailDelay:.18,arcDelay:.74,radius:94,lineCap:"flat",radiusDelta:.00999999999999999,rotations:1,backgroundColour:"#FFFF00"});C({cycleDuration_ms:2500,fps:120,colours:["#5bcefa","#f5a9b8","#ffffff","#f5a9b8","#5bcefa"],opacity:1,timingFunction:"sinusoidal",drawStyle:"fill",rest:.3,arcs:5,arcWidth:10,arcWidthDelta:.02,arcAnchor:"centre",tailDelay:.39,arcDelay:.02,radius:100,lineCap:"flat",radiusDelta:.08,rotations:1});k({});k({cycleDuration_ms:1500,fps:120,colours:["#FFc300","#ff5733","#c70039","#900C3F","#581845"],opacity:1,timingFunction:"sinusoidal",drawStyle:"fill",arcs:5,arcWidth:20,arcWidthDelta:-.04,tailDelay:.2,arcDelay:.02,radius:25,xOff:50,backgroundColour:"#020035"});k({cycleDuration_ms:1500,fps:120,colours:["#b21f29","#f05a35","#ffb94a","#207ea2","#68192f"],opacity:1,timingFunction:"sinusoidal",drawStyle:"fill",arcs:5,arcWidth:10,arcWidthDelta:.1,tailDelay:.2,arcDelay:.02,radius:20,radiusDelta:-.3,xOff:70});k({cycleDuration_ms:700,fps:120,colours:["#00ff9f","#00b8ff","#001eff","#bd00ff","#d600ff"],opacity:1,timingFunction:"sinusoidal",drawStyle:"fill",arcs:10,arcWidth:3,arcWidthDelta:-.04,tailDelay:.07,arcDelay:.37,radius:22,radiusDelta:-.11,xOff:80});k({cycleDuration_ms:1500,backgroundColour:"#222222",fps:120,colours:["#FFFFFF","#EEEEEE","#DDDDDD","#555555","#222222"],opacity:.7,timingFunction:"sinusoidal",drawStyle:"fill",arcs:8,arcWidth:21,tailDelay:.17,arcDelay:.43,radius:39,xOff:65});D({timingFunction:"linear",delay:0,cycleDuration_ms:2500});D({cycleDuration_ms:2500,fps:120,colours:["#581845","#900C3F","#c70039","#ff5733","#FFc300"],opacity:1,delay:.1,rest:.25,timingFunction:"sinusoidal",drawStyle:"stroke",sideLength:5,relativeExpansion:1,circleSize:25,rotations:1});D({cycleDuration_ms:2e3,fps:120,colours:["#FF0000","#00FF00","#0000FF"],opacity:1,timingFunction:"linear",drawStyle:"stroke",sideLength:20,relativeExpansion:1,circleSize:10,rotations:0,radiusPulse:{style:"disperse",delay:.15,intensity:.25},backgroundColour:"#000000"});D({cycleDuration_ms:2700,fps:120,colours:["#EAE2B7","#FCBF49","#F77F00","#D62828","#003049"],opacity:1,timingFunction:"sinusoidal",drawStyle:"fill",rest:.11,sideLength:5,relativeExpansion:1,circleSize:20,delay:.05,rotations:-2});D({cycleDuration_ms:2700,fps:120,colours:["#FF9AA2","#FFB7B2","#FFDAC1","#E2F0CB","#B5EAD7"],opacity:1,timingFunction:"sinusoidal",drawStyle:"fill",rest:.11,sideLength:25,relativeExpansion:1,circleSize:4,delay:.01,rotations:1,opacityPulse:{style:"coelesce",delay:.03,intensity:2}});
